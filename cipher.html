<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Encryption/Decryption Interface</title>
  <style>
    /* General Styling */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f2f2f2;
    }
    .container {
      max-width: 700px;
      margin: auto;
      background-color: #fff;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      color: #333;
    }
    /* Field Container Styling */
    .field-container {
      margin-bottom: 25px;
    }
    /* Header (Label + Button) Styling */
    .field-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .field-header label {
      font-weight: bold;
      font-size: 1em;
      color: #555;
      flex: 1; /* Allow label to take up available space */
      margin-right: 10px; /* Space between label and button */
    }
    /* Unified Emoji Button Styling */
    .icon-button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5em; /* Consistent emoji size */
      padding: 5px;
      border-radius: 4px;
      /* Removed transition to eliminate hover animations */
      /* Removed hover effects to maintain uniform look */
    }
    .icon-button:focus {
      outline: 2px solid #66afe9;
    }
    /* Input and Textarea Styling */
    textarea, input, select {
      width: 100%;
      padding: 12px 15px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      resize: vertical;
      transition: border-color 0.3s, background-color 0.3s;
      background-color: #f2f2f2; /* Light grey for normal operation */
    }
    textarea:focus, input:focus, select:focus {
      border-color: #66afe9;
      outline: none;
    }
    /* Input Error Styling */
    .error {
      background-color: #ffe6e6; /* Light red for error */
      border-color: #ff4d4d;
    }
    /* Result Display Styling */
    .result {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: #f9f9f9;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-height: 120px;
      font-family: monospace;
      color: #333;
      position: relative;
    }
    /* Spinner Styling */
    .spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
    }
    /* Responsive Design */
    @media (max-width: 600px) {
      .field-header {
        /* Maintain row layout but prevent wrapping */
        flex-wrap: nowrap; /* Prevent wrapping */
      }
      .field-header label {
        font-size: 0.9em;
        margin-right: 8px;
      }
      .icon-button {
        font-size: 1.3em; /* Adjust size for smaller screens */
      }
    }
    /* Suggestion Text Styling */
    .suggestion {
      font-size: 0.9em;
      color: #777;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Encryption/Decryption Interface</h1>
    
    <!-- Mode Toggle Field -->
    <div class="field-container">
      <div class="field-header">
        <label>Mode:</label>
        <!-- Unified Emoji Button with 'icon-button' class -->
        <button id="modeToggleButton" class="icon-button" title="Switch to Decrypt Mode" aria-label="Switch to Decrypt Mode">üîí</button>
      </div>
      <!-- Hidden input to store current mode -->
      <input type="hidden" id="mode" value="encrypt">
    </div>

    <!-- Input Data Field -->
    <div class="field-container">
      <div class="field-header">
        <label for="inputData" id="inputDataLabel">Input Data (Plaintext):</label>
        <!-- Unified Emoji Button for Paste -->
        <button id="pasteButton" class="icon-button" title="Paste from clipboard" aria-label="Paste from clipboard">üìã‚û°Ô∏è</button>
      </div>
      <textarea id="inputData" rows="5" placeholder="Enter text to encrypt"></textarea>
      <div class="suggestion" id="inputSuggestion">Please enter the text you want to encrypt.</div>
    </div>

    <!-- Passphrase Field -->
    <div class="field-container">
      <div class="field-header">
        <label for="passphrase">Passphrase:</label>
        <!-- Unified Emoji Button for Show/Hide Passphrase -->
        <button id="togglePassphrase" class="icon-button" title="Show passphrase" aria-label="Toggle passphrase visibility">üëÅÔ∏è</button>
      </div>
      <input type="password" id="passphrase" placeholder="Enter passphrase">
    </div>

    <!-- Result Display Area -->
    <div class="field-container" style="position: relative;">
      <div class="field-header">
        <label for="result">Result:</label>
        <!-- Unified Emoji Button for Copy -->
        <button id="copyButton" class="icon-button" title="Copy to clipboard" aria-label="Copy to clipboard">üìã‚¨ÖÔ∏è</button>
      </div>
      <div id="result" class="result" readonly></div>
      <!-- Spinner Indicator -->
      <div id="spinner" class="spinner">üîÑ</div>
    </div>
  </div>

  <script>
    // Debounce Function to Limit Frequency of Function Calls
    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    }

    // Function to convert ArrayBuffer to Base64
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    // Function to convert Base64 to ArrayBuffer
    function base64ToArrayBuffer(base64) {
      const binary_string = window.atob(base64);
      const len = binary_string.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    }

    // Encryption function
    async function encryptData(data, passphrase) {
      const enc = new TextEncoder();

      // Generate random salt and iv
      const salt = window.crypto.getRandomValues(new Uint8Array(16));
      const iv = window.crypto.getRandomValues(new Uint8Array(12));

      // Derive key using PBKDF2
      const keyMaterial = await window.crypto.subtle.importKey(
        'raw',
        enc.encode(passphrase),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );

      const key = await window.crypto.subtle.deriveKey(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: 100000,
          hash: 'SHA-256',
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt']
      );

      // Encrypt data
      const encrypted = await window.crypto.subtle.encrypt(
        {
          name: 'AES-GCM',
          iv: iv,
          tagLength: 128,
        },
        key,
        enc.encode(data)
      );

      // Split ciphertext and auth tag
      const encryptedBytes = new Uint8Array(encrypted);
      const ciphertext = encryptedBytes.slice(0, -16);
      const authTag = encryptedBytes.slice(-16);

      // Concatenate salt + iv + authTag + ciphertext
      const combinedData = new Uint8Array(
        salt.byteLength + iv.byteLength + authTag.byteLength + ciphertext.byteLength
      );
      combinedData.set(salt, 0);
      combinedData.set(iv, salt.byteLength);
      combinedData.set(authTag, salt.byteLength + iv.byteLength);
      combinedData.set(ciphertext, salt.byteLength + iv.byteLength + authTag.byteLength);

      // Convert to Base64
      return arrayBufferToBase64(combinedData.buffer);
    }

    // Decryption function
    async function decryptData(encryptedDataBase64, passphrase) {
      const enc = new TextEncoder();
      const encryptedData = base64ToArrayBuffer(encryptedDataBase64);
      const encryptedBytes = new Uint8Array(encryptedData);

      // Extract salt, iv, authTag, and ciphertext
      const salt = encryptedBytes.slice(0, 16);
      const iv = encryptedBytes.slice(16, 28);
      const authTag = encryptedBytes.slice(28, 44);
      const ciphertext = encryptedBytes.slice(44);

      // Derive key using PBKDF2
      const keyMaterial = await window.crypto.subtle.importKey(
        'raw',
        enc.encode(passphrase),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );

      const key = await window.crypto.subtle.deriveKey(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: 100000,
          hash: 'SHA-256',
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
      );

      // Combine ciphertext and authTag for decryption
      const dataToDecrypt = new Uint8Array([...ciphertext, ...authTag]);

      // Decrypt data
      const decrypted = await window.crypto.subtle.decrypt(
        {
          name: 'AES-GCM',
          iv: iv,
          tagLength: 128,
        },
        key,
        dataToDecrypt.buffer
      );

      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
    }

    // Function to update input labels and placeholders based on mode
    function updateInputFields(mode) {
      const inputDataLabel = document.getElementById('inputDataLabel');
      const inputData = document.getElementById('inputData');
      const inputSuggestion = document.getElementById('inputSuggestion');

      if (mode === 'encrypt') {
        inputDataLabel.textContent = 'Input Data (Plaintext):';
        inputData.placeholder = 'Enter text to encrypt';
        inputSuggestion.textContent = 'Please enter the text you want to encrypt.';
      } else if (mode === 'decrypt') {
        inputDataLabel.textContent = 'Input Data (Ciphertext):';
        inputData.placeholder = 'Enter ciphertext to decrypt';
        inputSuggestion.textContent = 'Please enter the ciphertext you want to decrypt.';
      }
    }

    // Function to validate input fields and determine if processing should occur
    function validateInputs() {
      const inputData = document.getElementById('inputData').value.trim();
      const passphrase = document.getElementById('passphrase').value.trim();
      const mode = document.getElementById('mode').value;

      const inputField = document.getElementById('inputData');
      const passphraseField = document.getElementById('passphrase');

      let valid = true;

      // Validate Input Data
      if (!inputData) {
        inputField.classList.add('error');
        valid = false;
      } else {
        inputField.classList.remove('error');
      }

      // Validate Passphrase
      if (!passphrase) {
        passphraseField.classList.add('error');
        valid = false;
      } else {
        passphraseField.classList.remove('error');
      }

      return valid;
    }

    // Function to display the spinner
    function showSpinner() {
      document.getElementById('spinner').style.display = 'block';
    }

    // Function to hide the spinner
    function hideSpinner() {
      document.getElementById('spinner').style.display = 'none';
    }

    // Function to display error messages in the result area
    function displayError(message) {
      const resultElement = document.getElementById('result');
      resultElement.textContent = message;
    }

    // Function to process encryption or decryption
    async function processData() {
      const isValid = validateInputs();
      if (!isValid) {
        displayError('');
        return;
      }

      const mode = document.getElementById('mode').value;
      const inputData = document.getElementById('inputData').value.trim();
      const passphrase = document.getElementById('passphrase').value;
      const resultElement = document.getElementById('result');

      showSpinner();
      displayError('');

      try {
        let output;
        if (mode === 'encrypt') {
          output = await encryptData(inputData, passphrase);
          resultElement.textContent = output;
        } else if (mode === 'decrypt') {
          output = await decryptData(inputData, passphrase);
          resultElement.textContent = output;
        }
      } catch (error) {
        console.error('Operation failed:', error);
        if (mode === 'decrypt') {
          displayError('Decryption failed. Incorrect passphrase or corrupted data.');
        } else {
          displayError('Encryption failed. Please try again.');
        }
      } finally {
        hideSpinner();
      }
    }

    // Debounced version of processData to prevent excessive calls
    const debouncedProcessData = debounce(processData, 100); // Reduced delay to 300ms

    // Event listener for Mode Toggle Button
    document.getElementById('modeToggleButton').addEventListener('click', () => {
      const modeInput = document.getElementById('mode');
      const modeToggleButton = document.getElementById('modeToggleButton');

      // Toggle mode value
      if (modeInput.value === 'encrypt') {
        modeInput.value = 'decrypt';
        modeToggleButton.textContent = 'üîì';
        modeToggleButton.title = 'Switch to Encrypt Mode';
        modeToggleButton.setAttribute('aria-label', 'Switch to Encrypt Mode');
        updateInputFields('decrypt');
      } else {
        modeInput.value = 'encrypt';
        modeToggleButton.textContent = 'üîí';
        modeToggleButton.title = 'Switch to Decrypt Mode';
        modeToggleButton.setAttribute('aria-label', 'Switch to Decrypt Mode');
        updateInputFields('encrypt');
      }

      // Clear previous results and trigger processing
      document.getElementById('result').textContent = '';
      debouncedProcessData();
    });

    // Event listeners for Input Data and Passphrase fields to trigger processing on input
    document.getElementById('inputData').addEventListener('input', debouncedProcessData);
    document.getElementById('passphrase').addEventListener('input', debouncedProcessData);

    // Paste button functionality
    document.getElementById('pasteButton').addEventListener('click', async () => {
      try {
        const text = await navigator.clipboard.readText();
        document.getElementById('inputData').value = text;
        debouncedProcessData();
      } catch (err) {
        alert('Failed to read clipboard contents: ' + err);
      }
    });

    // Copy button functionality
    document.getElementById('copyButton').addEventListener('click', async () => {
      const resultText = document.getElementById('result').textContent;
      if (resultText && resultText !== 'Decryption failed. Incorrect passphrase or corrupted data.' && resultText !== 'Encryption failed. Please try again.') {
        try {
          await navigator.clipboard.writeText(resultText);
          alert('Result copied to clipboard.');
        } catch (err) {
          alert('Failed to copy to clipboard: ' + err);
        }
      } else {
        alert('No valid result to copy.');
      }
    });

    // Toggle passphrase visibility functionality
    document.getElementById('togglePassphrase').addEventListener('click', () => {
      const passInput = document.getElementById('passphrase');
      const toggleButton = document.getElementById('togglePassphrase');
      if (passInput.type === 'password') {
        passInput.type = 'text';
        toggleButton.textContent = 'üôà';
        toggleButton.title = 'Hide passphrase';
        toggleButton.setAttribute('aria-label', 'Hide passphrase');
      } else {
        passInput.type = 'password';
        toggleButton.textContent = 'üëÅÔ∏è';
        toggleButton.title = 'Show passphrase';
        toggleButton.setAttribute('aria-label', 'Show passphrase');
      }
    });

    // Initial setup on page load
    window.addEventListener('load', () => {
      validateInputs();
      updateInputFields('encrypt'); // Initialize input fields
      processData(); // Trigger initial processing if needed
    });
  </script>
</body>
</html>
